package java08_abstract;
	//추상 메소드
	//-수행(동작)코드를 구현하지 않고 추상화시킨 메소드
	//-메소드의 구현부({}중괄호 영역)를 작성하지 않는다
	//-메소드의 머리(헤드)부분만 작성하고 {}중괄호 대신 ;으로 끝낸다
	//
	//추상 클래스
	//-인스턴스화(실체화)할 수 없는 클래스
	//-new연산자를 이용한 객체 생성을 문법으로 막고 있다
	//-단, 데이터 타입으로만 사용하여 객체 변수를 선언할 수는 있다
	//-추상 메소드를 멤버로 가질 수 있다
	//-하지만 반드시 추상 메소드를 멤버로 가져야하는 것은 아니다.
	//
	//**추상 메소드는 자식 클래스로 상속된다
	//**추상 메소드를 멤버로 가지려면 추상 클래스가 되어야 한다.
	//**상속받은 추상 메소드를 오버라이딩하면 추상 클래스로 지정하지 않아도 된다.
	//→ 추상 메소드를 반드시 오버라이딩하도록 강제할 수 있다.
	//다형성(Polymorphism)
	//-객체지향언어의 특징 중 하나
	//-한 요소(자료형)이 다양한 모습(특징)으로 표현되거나, 기능을 수행하는 특성
	//-부모 클래스 타입의 객체 변수를 이용하여 다양한 자식 클래스 타입으로 사용한다.
	// -> 부모 타입 객체 변수에 자식 타입을 대입해서 사용한다.
	// -> 오버라이딩 메소드를 호출할 때 동적바인딩해서
	// 다양한 자식 클래스들의 기능을 적절히 수행한다.
	//-오늘(7/11)풀었던 Point, Product, Person 문제에서 모두 나타나고 있다.
	//
	//** 객체지향언어의 대표적 특징
	//-추상화, 캡슐화, 상속, 다형성
	
public class AbstractEx {
	public static void main(String[] args) {
		
		Professor pf = new Professor("Alice", "컴퓨터");
		Student st = new Student("Bob", "자바");
		//부모 클래스가 교수와 학생 모두를 대표해준다.
		//이것을 이용해서 상속의 이점이 발생한다.
		pf.display();
		st.display();
		
		System.out.println("-----------------------------------");
		
		Person p1 = new Professor("Clare", "인공지능");
		Person p2 = new Student("Dave", "알고리즘");
		//new는 자식으로 했기 때문에 Person은 그냥 자료형으로만 쓰이고 있다.
		//위에 비해 좀더 프로그램이 유연해진다.
		//하지만, 지금 이 방식의 프로그래밍은 정적 바인딩이 안되어 문제가 발생한다.
		
		p1.display();
		p2.display();
		
		System.out.println("-----------------------------------");

		//추상클래스로 변수 선언은 가능
		Person p3;
		
		//에러, 추상클래스를 객체생성(new, 인스턴스화)할 수 없다.
//		p3 = new Person("TEST");//인스턴스화(실체화)할 수 없다는 에러 발생.
	
		//추상 클래스의 특별한 문법 - 자동완성(Ctrl+Space)을 했을때 볼수 있다.
		
		Person p4 = new Person( "Edward" ) {//Person에 추가할 클래스 정의
			
			@Override
			public void display() {
				System.out.println("익명 클래스 정의, Anonymous Class");
			}
		};
		
		p4.display(); // p4 전용으로 Person에 추가된 일회용 클래스가 있다.
		//이러한 익명 클래스 형태의 개발은 프로그래밍에서 상당히 자주 쓰인다.
		
		
	}
}
